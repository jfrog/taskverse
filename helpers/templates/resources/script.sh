set -e

# Set Environment Variables
{{- range $key, $value := .EnvironmentVariables }}
export {{ $key }}="{{ $value }}"
{{- end }}

# Add tools to PATH
export PATH="$(dirname $jfrog_cli_path):$PATH"
echo "Using JFrog CLI $(jfrog -v)"
export PATH="$(dirname $JFROG_PIPE_CLI_PATH):$PATH"
export PATH="{{ .PathToDependencies }}/docker:$PATH"

# Create key folders if not present
mkdir -p $JFROG_PIPELINE_WORKSPACE_DIR
mkdir -p $run_dir
mkdir -p $JFROG_STEP_WORKSPACE_DIR
mkdir -p $step_dependency_state_dir
mkdir -p $step_output_dir
mkdir -p $JFROG_SHARED_WORKSPACE_DIR
mkdir -p $steplet_workspace_dir
mkdir -p $JFROG_POST_HOOKS_DIR
mkdir -p $JFROG_STEP_TMP_DIR
mkdir -p $JFROG_STEPLET_RUN_STATE_DIR

# Load utility Functions
source {{ .PathToDependencies }}/header.sh

# Delete any existing containers
docker rm -fv $(docker ps -aq) > /dev/null 2>&1 || true

# Invoke task
echo ""
echo "TASK => execution"
invoke_task --name {{ .PathToTask }} --id task {{ .TaskParameters }}
echo ""

# Invoke user defined post task script if available
if test -f "$JFROG_DEV_POST_TASK_SCRIPT_PATH"; then
  echo "POST TASK SCRIPT"
  source $JFROG_DEV_POST_TASK_SCRIPT_PATH
  echo ""
fi

# TODO: Support additional hooks
# Invoke onComplete hook
{{- if .EnableOnStepCompleteHook }}
if test -f "$JFROG_POST_HOOKS_DIR/onComplete.sh"; then
  echo "TASK => onStepComplete"
  source $JFROG_POST_HOOKS_DIR/onComplete.sh
  echo ""
fi
{{- end }}

# Copy files generated by the task to developer workspace
mkdir -p $JFROG_DEV_TOOL_FOLDER/task
pushd /task_workspace/*
if test -f "./task_runtime/outputs.env"; then
  cp ./task_runtime/outputs.env $JFROG_DEV_TOOL_FOLDER/task/outputs.env
fi
if test -f "./task_runtime/exports.env"; then
  cp ./task_runtime/exports.env $JFROG_DEV_TOOL_FOLDER/task/exports.env
fi
if test -f "./task_runtime/path.append"; then
  cp ./task_runtime/path.append $JFROG_DEV_TOOL_FOLDER/task/path.append
fi
if test -d "./task_state"; then
  cp -r ./task_state $JFROG_DEV_TOOL_FOLDER/task/task_state
fi

